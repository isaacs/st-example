{
  "name": "st",
  "version": "0.1.2",
  "description": "A module for serving static files.  Does etags, caching, etc.",
  "main": "st.js",
  "bin": {
    "st": "bin/server.js"
  },
  "dependencies": {
    "lru-cache": "~2.0.0",
    "mime": "~1.2.7",
    "negotiator": "~0.2.5",
    "async-cache": "~0.0.2",
    "fd": "~0.0.2",
    "graceful-fs": "~1.1.13"
  },
  "optionalDependencies": {
    "graceful-fs": "~1.1.13"
  },
  "devDependencies": {
    "tap": "~0.3.1",
    "request": "~2.11.4"
  },
  "scripts": {
    "test": "tap test/*.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/isaacs/st"
  },
  "keywords": [
    "static",
    "file",
    "serve",
    "etag",
    "autoindex",
    "cache"
  ],
  "author": {
    "name": "Isaac Z. Schlueter",
    "email": "i@izs.me",
    "url": "http://blog.izs.me/"
  },
  "license": "BSD",
  "readme": "# st\n\nA module for serving static files.  Does etags, caching, etc.\n\n## USAGE\n\nIn your JavaScript program:\n\n```javascript\nvar st = require('st')\nvar mount = st({\n  path: 'resources/static/',\n  url: 'static/', // defaults to path option\n\n  cache: {\n    fd: {\n      max: 1000, // number of fd's to hang on to\n      maxAge: 1000*60*60, // amount of ms before fd's expire\n    },\n\n    stat: {\n      max: 5000, // number of stat objects to hang on to\n      maxAge: 1000 * 60, // number of ms that stats are good for\n    },\n\n    content: {\n      max: 1024*1024*64, // how much memory to use on caching contents\n      maxAge: 1000 * 60 * 10, // how long to cache contents for\n    },\n\n    index: { // irrelevant if not using index:true\n      max: 1024 * 8, // how many bytes of autoindex html to cache\n      maxAge: 1000 * 60 * 10, // how long to store it for\n    },\n\n    readdir: { // irrelevant if not using index:true\n      max: 1000, // how many dir entries to cache\n      maxAge: 1000 * 60 * 10, // how long to cache them for\n    }\n  },\n\n  // indexing options\n  index: true, // auto-index\n  index: 'index.html', // use 'index.html' file as the index\n  index: false, // return 404's for directories\n\n  dot: false, // default: return 403 for any url with a dot-file part\n  dot: true, // allow dot-files to be fetched normally\n\n  passthrough: true, // calls next instead of returning a 404 error\n  passthrough: false, // returns a 404 when a file or an index is not found\n})\n\n// with bare node.js\nhttp.createServer(function (req, res) {\n  if (mount(req, res)) return // serving a static file\n  myCustomLogic(req, res)\n}).listen(PORT)\n\n// with express\napp.use(mount)\n// or\napp.route('/static/:fooblz', function (req, res, next) {\n  mount(req, res, next) // will call next() if it doesn't do anything\n})\n```\n\nOn the command line:\n\n```\n$ st -h\nst\nStatic file server in node\n\nOptions:\n\n-h --help             Show this help\n\n-p --port PORT        Listen on PORT (default=1337)\n\n-d --dir DIRECTORY    Serve the contents of DIRECTORY (default=cwd)\n\n-i --index [INDEX]    Use the specified INDEX filename as the result\n                      when a directory is requested.  Set to \"true\"\n                      to turn autoindexing on, or \"false\" to turn it\n                      off.  If no INDEX is provided, then it will turn\n                      autoindexing on.  (default=true)\n\n-ni --no-index        Same as \"--index false\"\n\n-. --dot [DOT]        Allow .files to be served.  Set to \"false\" to\n                      disable.\n\n-n. --no-dot          Same as \"--dot false\"\n\n-nc --no-cache        Turn off all caching.\n\n-a --age AGE          Max age (in ms) of cache entries.\n```\n\n## Range Requests\n\nRange requests are not supported.\n\nI'd love a patch to add support for them, but the spec is kind of\nconfusing, and it's not always a clear win if you're not serving very\nlarge files, so it should come with some very comprehensive tests.\n\nThankfully, as far as I can tell, it's always safe to serve the entire\nfile to a request with a range header, so st does behave correctly, if\nnot ideally in those situations.  It'd be great to be able to do the\nbetter thing if the contents are cached, but still serve the full file\nif it's not in cache (so that it can be cached for subsequent\nrequests).\n\n## Memory Caching\n\nTo make things go as fast as possible, it is a good idea to set the\ncache limits as high as you can afford, given the amount of memory on\nyour server.  Serving buffers out of process memory will generally\nalways be faster than hitting the file system.\n\n## Client Caching\n\nAn etag header and last-modified will be attached to every request.\nIf presented with an `if-none-match` or `if-modified-since`, then\nit'll return a 304 in the appropriate conditions.\n\nThe etag is generated based on the dev, ino, and last modified date.\nStat results are cached.\n\n## Compression\n\nIf the request header claims to enjoy gzip encoding, and the filename\ndoes not end in '.gz' or '.tgz', then the response will be gzipped.\n\nGzipped bytes are not included in the calculation of cache sizes, so\nthis utility will use a bit more memory than the cache.content.max and\ncache.index.max bytes would seem to allow.  This will be less than\ndouble, and usually insignificant for normal web assets, but is\nimportant to consider if memory is at a premium.\n\n## Filtering Output\n\nIf you want to do some fancy stuff to the file before sending it, you\ncan attach a `res.filter = myFilterStream` thing to the response\nobject before passing it to the mount function.\n\nThis is useful if you want to get the benefits of caching and gzipping\nand such, but serve stylus files as css, for example.\n",
  "readmeFilename": "README.md",
  "_id": "st@0.1.2",
  "_from": "st@"
}
